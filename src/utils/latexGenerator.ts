import { ResumeData } from '@/types/resume';

export function generateLatexFromResume(resumeData: ResumeData): string {
  const { personalInfo, education, experience, skills, summary } = resumeData;

  const latex = `% Generated by Professional Resume Builder
% Open in Overleaf for editing and PDF compilation

\\documentclass[11pt,a4paper,sans]{moderncv}

% Modern CV theme and color
\\moderncvstyle{classic}
\\moderncvcolor{blue}

% Character encoding and language
\\usepackage[utf8]{inputenc}
\\usepackage[english]{babel}

% Adjust margins
\\usepackage[scale=0.75]{geometry}

% Personal data
\\name{${escapeLatex(personalInfo.fullName.split(' ')[0] || '')}}{${escapeLatex(personalInfo.fullName.split(' ').slice(1).join(' ') || '')}}
${personalInfo.address ? `\\address{${escapeLatex(personalInfo.address)}}` : ''}
${personalInfo.phone ? `\\phone[mobile]{${escapeLatex(personalInfo.phone)}}` : ''}
${personalInfo.email ? `\\email{${escapeLatex(personalInfo.email)}}` : ''}
${personalInfo.website ? `\\homepage{${escapeLatex(personalInfo.website)}}` : ''}
${personalInfo.linkedin ? `\\social[linkedin]{${escapeLatex(personalInfo.linkedin)}}` : ''}
${personalInfo.github ? `\\social[github]{${escapeLatex(personalInfo.github)}}` : ''}

\\begin{document}

\\makecvtitle

${summary ? `
\\section{Summary}
\\cvitem{}{${escapeLatex(summary)}}
` : ''}

${education.length > 0 ? `
\\section{Education}
${education.map(edu => `\\cventry{${escapeLatex(edu.startDate)}--${escapeLatex(edu.endDate)}}{${escapeLatex(edu.degree)}}{${escapeLatex(edu.institution)}}{${escapeLatex(edu.fieldOfStudy)}}{${edu.gpa ? `GPA: ${escapeLatex(edu.gpa)}` : ''}}{${edu.achievements ? edu.achievements.map(a => escapeLatex(a)).join('\\\\') : ''}}`).join('\n')}
` : ''}

${experience.length > 0 ? `
\\section{Experience}
${experience.map(exp => `\\cventry{${escapeLatex(exp.startDate)}--${exp.current ? 'Present' : escapeLatex(exp.endDate)}}{${escapeLatex(exp.position)}}{${escapeLatex(exp.company)}}{${exp.location ? escapeLatex(exp.location) : ''}}{}{
${exp.description.map(desc => `\\item ${escapeLatex(desc)}`).join('\n')}
}`).join('\n')}
` : ''}

${skills.length > 0 ? `
\\section{Skills}
${generateSkillsSection(skills)}
` : ''}

\\end{document}`;

  return latex;
}

function escapeLatex(text: string): string {
  if (!text) return '';
  
  return text
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/[{}]/g, '\\$&')
    .replace(/\$/g, '\\$')
    .replace(/[%&#^_~]/g, '\\$&')
    .replace(/\n/g, ' ')
    .trim();
}

function generateSkillsSection(skills: { name: string; category: string; level?: string }[]): string {
  const categories = skills.reduce((acc, skill) => {
    if (!acc[skill.category]) {
      acc[skill.category] = [];
    }
    acc[skill.category].push(skill);
    return acc;
  }, {} as Record<string, typeof skills>);

  return Object.entries(categories)
    .map(([category, categorySkills]) => {
      const skillNames = categorySkills.map(s => escapeLatex(s.name)).join(', ');
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      return `\\cvitem{${categoryName}}{${skillNames}}`;
    })
    .join('\n');
}

export function validateLatexSyntax(latex: string): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check for balanced braces
  let braceCount = 0;
  for (const char of latex) {
    if (char === '{') braceCount++;
    if (char === '}') braceCount--;
    if (braceCount < 0) {
      errors.push('Unmatched closing brace found');
      break;
    }
  }
  
  if (braceCount > 0) {
    errors.push('Unmatched opening brace found');
  }
  
  // Check for required document structure
  if (!latex.includes('\\documentclass')) {
    errors.push('Missing \\documentclass declaration');
  }
  
  if (!latex.includes('\\begin{document}')) {
    errors.push('Missing \\begin{document}');
  }
  
  if (!latex.includes('\\end{document}')) {
    errors.push('Missing \\end{document}');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}